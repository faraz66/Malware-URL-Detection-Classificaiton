# -*- coding: utf-8 -*-
"""Malicious URL Detection_and_Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gRZXveQIgR4pRKz-8Xo3R28rs8eh6Uxo

# Malicious URL Detection - For Newly Generated Domains

# FAQ

*** Q) When we have Alerts and Anomily detection for Blacklisted domains which can detect malicious URL trying to make request on Servers via IDS and Poilices,then.. ***

* Why do we need a model,are we trying to solve something new ?

* What are the differences,can you explain with an example ?

**Q) Previously, filtering the domains against blacklists was the only way to detect malicious domains, however, this approach was unable to detect newly generated domains Recently, Machine Learning (ML) techniques have helped to enhance the detection capability of domain vetting systems.**                                                              

* A solid feature engineering mechanism plays a pivotal role in boosting the performance of any ML model.
* Therefore, we have extracted effective and practical features from DNS traffic categorizing them into three groups of                       lexical-based, DNS statistical-based, and third party-based features.  
* Third party features are biographical information about a specific domain extracted from third party APIs
* In this research work, we generate and release a large DNS features dataset of **400,000** benign and **13,011** malicious samples processed from a million benign and **51,453** known-malicious domains from publicly available datasets.

#INFORMATION OF DATASET


The malicious samples span between three categories of

1. Spam
2. Phishing
3. Malware


Our dataset, namely CIC-Bell-DNS2021 replicates the real-world scenarios with frequent benign traffic and diverse malicious domain types.
[PhisTank](https://phishtank.org/developer_info.php)                   [ CIC-Bell-DNS2021  ](http://205.174.165.80/CICDataset/CICBellDNS2021/Dataset/)

# Malicious URL Feature Engineering
This notebook demonstrates the preprocessing and feature engineering of malicious URLs.                                          It extracts several lexical features from the URLs that can be used for further analysis.

## 1. Importing Required Libraries
"""

import pandas as pd
import numpy as np
from urllib.parse import urlparse
from collections import Counter
import math
import itertools
import whois
import requests
import tldextract
import logging
from datetime import datetime, timedelta
from dateutil import parser
import concurrent.futures
import os
import json
import tldextract
import tempfile
import time
import seaborn as sns
import matplotlib.pyplot as plt
from google.colab import drive

"""## 2. Loading the Data"""

# Step 1: Mount Google Drive
from google.colab import drive
import pandas as pd

drive.mount('/content/drive')

# Step 2: Load the CSV from Google Drive
file_path = '/content/drive/My Drive/ml_datasets/phistank_test.csv'
df = pd.read_csv(file_path)

# Preview the data
df.head()

"""## 3.  DATA Preprocessing
We will drop some unnecessary columns for simplicity.
"""

# Drop unnecessary columns
columns_to_drop = ['phish_detail_url', 'submission_time', 'verification_time']
df_cleaned = df.drop(columns=columns_to_drop)
df_cleaned.head()

# Drop unnecessary columns
columns_to_drop = ['phish_detail_url', 'submission_time', 'verification_time']
df_cleaned = df.drop(columns=columns_to_drop)
df_cleaned.head()

"""## 4. Feature Engineering
In this section, we extract a variety of lexical features from the URLs, such as subdomains, top-level domains, numeric percentages, and more.

**Lexical Features**
*  F1	Subdomain	Has sub-domain or not
*  F2	TLD	Top-level domain
*  F3	SLD	Second-level domain
*  F4	Len	Length of domain and subdomain
*  F5	Numeric percentage	Counts the number of digits in domain and subdomain
*  F6	Character distribution	Counts the number of each letter in the domain
*  F7	Entropy	Entropy of letter distribution
*  F8 1-gram of the domain in letter level
*  F9	2-gram of the domain in letter level
*  F10 3-gram of the domain in letter level
*  F11	Longest word	Longest meaningful word in SLD
*  F12	Distance from bad words	Computes average distance from bad words
*  F13	Typos	Typosquatting
*  F14	Obfuscation	Max value for URL obfuscation  List item

### Third party

*   F15	Registrar	Registrar of the domain
*   F16	Registrant name	The name the domain has been registered
*   F17	Emails	The emails associated to a domain
*   F18	Domain age	The age of a domain
*   F19	Organization	What organization it is linked to
*   F20	State	The state the main branch is
*   F21	Country	The country the main branch is
*   F22	Name server count	The total number of name servers linked to the domain
*   F23	Alexa rank	The rank of the domain by Alexa

### 4.1 Domain Extraction -Subdomain,TLD,SLD
"""

# Function to manually extract subdomain, TLD, and SLD from the URL
def manual_extract_domain_features(url):
    try:
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname
        if hostname:
            parts = hostname.split('.')
            if len(parts) > 2:  # There's a subdomain
                subdomain = '.'.join(parts[:-2])
                sld = parts[-2]
                tld = parts[-1]
            else:  # No subdomain
                subdomain = ''
                sld = parts[-2] if len(parts) >= 2 else ''
                tld = parts[-1] if len(parts) >= 2 else ''
            return subdomain, tld, sld
        return '', '', ''  # Return empty if parsing fails
    except Exception:
        return '', '', ''  # Handle invalid URLs by returning empty components

# Apply domain extraction
df_cleaned[['subdomain', 'tld', 'sld']] = df_cleaned['url'].apply(lambda x: pd.Series(manual_extract_domain_features(x)))
df_cleaned.head()

"""### 4.2 Basic Lexical Features

"""

# Feature 1: Has Subdomain or not (binary)
df_cleaned['has_subdomain'] = df_cleaned['subdomain'].apply(lambda x: 1 if x else 0)
# Feature 4: Length of domain (SLD + subdomain)
df_cleaned['domain_length'] = df_cleaned.apply(lambda row: len(row['sld']) + (len(row['subdomain']) if row['subdomain'] else 0), axis=1)

# Feature 5: Numeric percentage in domain and subdomain
def numeric_percentage(domain, subdomain):
    combined = domain + subdomain
    if len(combined) == 0:
        return 0
    digit_count = sum(c.isdigit() for c in combined)
    return (digit_count / len(combined)) * 100

df_cleaned['numeric_percentage'] = df_cleaned.apply(lambda row: numeric_percentage(row['sld'], row['subdomain']), axis=1)
df_cleaned.head()

"""### 4.3 Character Distribution and Entropy"""

# Feature 6: Character distribution
def char_distribution(domain, subdomain):
    combined = domain + subdomain
    char_count = Counter(combined)
    total = sum(char_count.values())
    return {char: count / total for char, count in char_count.items()} if total > 0 else {}

df_cleaned['char_distribution'] = df_cleaned.apply(lambda row: char_distribution(row['sld'], row['subdomain']), axis=1)

# Feature 7: Entropy
def entropy(char_dist):
    if not char_dist:
        return 0
    return -sum(freq * math.log2(freq) for freq in char_dist.values())

df_cleaned['entropy'] = df_cleaned['char_distribution'].apply(entropy)
df_cleaned.head()

# Assuming `data` is your DataFrame with a 'url' column
def extract_advanced_features(url):
    features = {}

    # Domain info using tldextract
    domain_info = tldextract.extract(url)
    #features['domain'] = domain_info.domain
    #features['subdomain'] = domain_info.subdomain
    #features['suffix'] = domain_info.suffix

    # URL length
    features['url_length'] = len(url)

    # Number of subdomains
    features['subdomain_count'] = url.count('.')

    # Check for suspicious keywords in URL
    features['has_suspicious_keywords'] = any(keyword in url.lower() for keyword in ['login', 'secure', 'free', 'account', 'bank'])

    # Count the number of special characters
    features['special_char_count'] = sum([1 for char in url if char in ['@', '%', '&', '=', '?']])

    return features

# Apply the function to each row in the 'url' column
feature_df = data['url'].apply(extract_advanced_features)

# Convert the result to a DataFrame
features_df = pd.DataFrame(list(feature_df))
df_cleaned = pd.concat([df_cleaned, features_df], axis=1)

df_cleaned.head()

"""### 4.4 Advanced Features

## Third Party Feature Engineering
---
*   Batch Processing of API Calls
*   Parallel Exceution of Process
*   Saving Entires into cache memory to avoid Unecessary Loading and API Calls
"""

# Set up logging for timeouts and errors
logging.basicConfig(level=logging.ERROR)

# Initialize cache dictionary to store WHOIS results
cache_file = "whois_cache.json"

# Handle corrupted cache files
def load_cache():
    if os.path.exists(cache_file):
        try:
            with open(cache_file, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            logging.error("Corrupted cache file. Starting with a new cache.")
            return {}
    return {}

# Load the cache or start fresh if corrupted
whois_cache = load_cache()

# Function to serialize WHOIS data (handle datetime and other non-serializable objects)
def serialize_whois_data(data):
    if isinstance(data, dict):
        return {key: serialize_whois_data(value) for key, value in data.items()}
    elif isinstance(data, list):
        return [serialize_whois_data(item) for item in data]
    elif isinstance(data, datetime):
        return data.isoformat()  # Convert datetime to string
    return data

# Function to deserialize WHOIS data (convert datetime strings back)
def deserialize_whois_data(data):
    if isinstance(data, dict):
        for key, value in data.items():
            if isinstance(value, str) and 'T' in value:  # Rough check if it's an ISO datetime string
                try:
                    data[key] = parser.isoparse(value)
                except Exception:
                    pass
            elif isinstance(value, dict):
                data[key] = deserialize_whois_data(value)
    return data

# Save cache to disk at the end of processing
def save_cache():
    try:
        with open(cache_file, 'w') as f:
            json.dump({domain: serialize_whois_data(data) for domain, data in whois_cache.items()}, f)
    except Exception as e:
        logging.error(f"Failed to save cache: {e}")

# Function to clean and extract domains from URLs
def clean_url(url):
    try:
        extracted = tldextract.extract(url)
        domain = f"{extracted.domain}.{extracted.suffix}"
        if domain:  # Only return if a valid domain is extracted
            return domain
    except Exception as e:
        logging.error(f"Error extracting domain from {url}: {e}")
        return None
    return None

# Function to perform WHOIS lookup with caching
def cached_whois(domain):
    domain = clean_url(domain)
    if domain is None:
        return {"error": "Invalid domain"}

    # Check if the domain is in cache
    if domain in whois_cache:
        return deserialize_whois_data(whois_cache[domain])

    # Perform WHOIS lookup if not in cache
    try:
        whois_data = whois.whois(domain)
        # Cache the result
        whois_cache[domain] = serialize_whois_data(whois_data)
        return whois_data
    except Exception as e:
        logging.error(f"Error retrieving WHOIS data for {domain}: {e}")
        return {"error": str(e)}

# Function to extract domain features from WHOIS data
def extract_domain_features(domain):
    features = {}
    domain_info = cached_whois(domain)

    if 'error' in domain_info:
        return features  # Skip domains with errors

    # Extract WHOIS data features
    features['Registrar'] = domain_info.get('registrar', None)
    features['Registrant Name'] = domain_info.get('name', None)
    emails = domain_info.get('emails', None)
    if isinstance(emails, list):
        emails = ", ".join(emails)  # Join list into a string if multiple emails exist
    features['Emails'] = emails
    creation_date = domain_info.get('creation_date', None)
    if creation_date:
        if isinstance(creation_date, list):
            creation_date = creation_date[0]
        if isinstance(creation_date, str):
            try:
                creation_date = parser.parse(creation_date)
            except ValueError:
                creation_date = None
        if creation_date:
            creation_date = creation_date.replace(tzinfo=None)
            age = (datetime.now() - creation_date).days // 365
            features['Domain Age (years)'] = age
        else:
            features['Domain Age (years)'] = None
    else:
        features['Domain Age (years)'] = None
    features['Organization'] = domain_info.get('org', None)
    features['State'] = domain_info.get('state', None)
    features['Country'] = domain_info.get('country', None)
    name_servers = domain_info.get('name_servers', None)
    features['Name Server Count'] = len(name_servers) if isinstance(name_servers, list) else 0
    return features

# Function to process WHOIS lookup for a batch of domains using parallel execution
def process_domains_in_parallel(df, batch_size=1000, max_workers=10):
    total_records = len(df)
    start_time = time.time()

    # Initialize an empty list to store processed results
    processed_data_list = []

    for i in range(0, total_records, batch_size):
        batch = df['url'][i:i+batch_size]
        print(f"\nProcessing batch {i+1} to {i+len(batch)} out of {total_records} records")
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {executor.submit(extract_domain_features, domain): domain for domain in batch}
            for future in concurrent.futures.as_completed(futures):
                domain = futures[future]
                try:
                    features = future.result()
                    features['url'] = domain  # Ensure we add the actual domain (url)
                    processed_data_list.append(features)
                except Exception as e:
                    logging.error(f"Error processing domain {domain}: {e}")

    processed_data = pd.DataFrame(processed_data_list)
    return processed_data

# Function to apply WHOIS feature extraction on unique URLs
def apply_feature_engineering(df):
    # Process unique URLs in parallel for WHOIS lookups
    return process_domains_in_parallel(df)

# 1. Assume `df_cleaned` is loaded
# Clean the URL using actual URLs for WHOIS lookup (unique values only to avoid redundancy)
df_cleaned['cleaned_url'] = df_cleaned.apply(lambda row: f"{row['sld']}.{row['tld']}", axis=1)

# 2. Extract unique URLs from 'url' for WHOIS lookup
unique_urls = df_cleaned['url'].drop_duplicates().reset_index(drop=True)
df_url_proc = pd.DataFrame(unique_urls, columns=['url'])  # Use actual URLs for WHOIS lookup

# 3. Apply WHOIS feature extraction on the unique URLs
df_processed = apply_feature_engineering(df_url_proc)

# 4. Save the cache after WHOIS lookup processing
save_cache()

# 5. Fill missing WHOIS data with NA for consistency
df_processed = df_processed.reindex(columns=['url', 'Registrar', 'Registrant Name', 'Emails', 'Domain Age (years)', 'Organization', 'State', 'Country', 'Name Server Count'])
df_processed = df_processed.fillna('NA')

# 6. Merge WHOIS data back to the original dataframe using 'url' and keep all original rows intact
df_cleaned = df_cleaned.merge(df_processed, on='url', how='left')

# 7. Drop the 'cleaned_url' column if no longer needed
df_cleaned = df_cleaned.drop(columns=['cleaned_url'], errors='ignore')

# 8. Ensure that the dataframe retains the original structure (same number of rows and order)
df_cleaned = df_cleaned.sort_index()

# 9. Display the updated dataframe
print(df_cleaned)

df_cleaned.head()

"""## N -GRAMS,Longest Meaningful Word ,TypoSquatting,Obfuscation"""

# Function to generate n-grams from domain and subdomain
def n_grams(domain, subdomain, n):
    # Ensure domain and subdomain are strings, replace NaN/float with empty string
    domain = str(domain) if pd.notna(domain) else ""
    subdomain = str(subdomain) if pd.notna(subdomain) else ""

    # Combine domain and subdomain
    combined = domain + subdomain

    # Generate n-grams
    return [combined[i:i+n] for i in range(len(combined) - n + 1)]

# Feature 11: Longest meaningful word in SLD
english_words_set = {"login", "free", "metamask", "webflow", "service"}

def longest_meaningful_word(sld):
    # Ensure sld is a string, handle NaN/float
    sld = str(sld) if pd.notna(sld) else ""

    # Split the SLD and find the longest meaningful word
    words = sld.split('-')
    meaningful_words = [word for word in words if word in english_words_set]
    return max(meaningful_words, key=len) if meaningful_words else ''

df_cleaned['longest_word'] = df_cleaned['sld'].apply(longest_meaningful_word)

# Feature 12: Distance from bad words
bad_words_list = ["scam", "fraud", "phish"]

def levenshtein_distance(a, b):
    if not a: return len(b)
    if not b: return len(a)
    if a[0] == b[0]:
        return levenshtein_distance(a[1:], b[1:])
    return 1 + min(levenshtein_distance(a[1:], b), levenshtein_distance(a, b[1:]), levenshtein_distance(a[1:], b[1:]))

def average_distance_from_bad_words(sld):
    sld = str(sld) if pd.notna(sld) else ""  # Ensure SLD is a string
    distances = [levenshtein_distance(sld, bad_word) for bad_word in bad_words_list]
    return sum(distances) / len(distances) if distances else 0

# df_cleaned['distance_from_bad_words'] = df_cleaned['sld'].apply(average_distance_from_bad_words)

# Feature 13: Typosquatting
common_typos = ['login', 'paypal', 'service']

def detect_typosquatting(sld):
    sld = str(sld) if pd.notna(sld) else ""  # Ensure SLD is a string
    return any(typo in sld for typo in common_typos)

df_cleaned['typosquatting'] = df_cleaned['sld'].apply(detect_typosquatting)

# Feature 14: URL Obfuscation
def obfuscation_score(subdomain, sld):
    subdomain = str(subdomain) if pd.notna(subdomain) else ""  # Ensure subdomain is a string
    sld = str(sld) if pd.notna(sld) else ""  # Ensure SLD is a string
    return len(subdomain) + len(sld)

df_cleaned['obfuscation_score'] = df_cleaned.apply(lambda row: obfuscation_score(row['subdomain'], row['sld']), axis=1)

# Display the updated DataFrame
df_cleaned.head()

# #Download Csv on Local Machine
# from google.colab import files

# df_cleaned.to_csv('malicious_url_features.csv', encoding='utf-8')
# files.download('malicious_url_features.csv')

"""### SUMMARY
![Screenshot 2024-10-03 135346.png](data:image/png;base64,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s2TEiBEyefJk6dy5c8pzII45c8cdd8ikSZPkxhtv9FJ+LPef//ynzs8g1HPChAnaJsPILlIyLqpXr65fNzn33HOlSZMmXmr2cM4550jBggW9T0bc4DHdcsstcuTIETUORo4cKfv27dM07iWiaNGiUqRIEcmTJ4+X8hP33nuv9OjRQ9atW+elGMapA3OFPxb085//3EsRufrqq1UfHj16VD+nOgfimDMffvih/q2BGjVqeCmiv//www+ycuVKL8UwcpY8DRs2/HFWZECDBg3krrvuklWrVsmll14q8+bNU4udydWlSxcpVaqU7N+/X5599lnp2LGjCjbfeT377LNl69at6u2uWbNG+vfvL3Xr1uWvd8knn3wiw4YNk8qVK+uidv755+u7Pv/88/Q/xsHXW/AYxo8fr5+N5ET9i4N//OMftd8xKubOnatpzZo1k969e8v69ev1c/HixaVPnz4alfjd736n43jRRReptwYori+++EI9uSeffFI9qK+++koeeughjWy0a9dOlTFp48aNU+O0UaNGOqYo6iVLlkjjxo3VYNm1a5cMHTpUVq9erWUbRk4Qdb7g5Xft2lUNcAwJ5gP6buDAgVKhQgWdE9OnT5crrrhC5Z2oK/PhkksuUUP83//+t2zbtk2jC35579u3r+afOHGilonzhh4888wz5e2335ann35aevXqpZGIAgUKyPbt29W4Hz16tMyZM8ernWhZxYoVkz/84Q9aHvOReYYuxRjiryjyxxJxJCi/TZs2Wkbz5s2Pm+fLli3TSAxRj4svvljn6vLly+Wll16Sbt26HdOm4cOHezUwjB/n09KlS/X3yJELDIIzzjhDFixYIDt37pRq1arphMK4wGpmy6RDhw7pCxWCjuGAACO8bdu2VaPjZz/7mTz++OMyaNAgtfh55uabb9bvx/7lL3+RX/ziFzop33zzTZ2AjzzyiBkW2QBjgrJx4wX8Thr3wkA5Yox8++23qmgwIsLA2EAZonwYX/7mPOMPyAxKEUWNDG3atEnzID9mWBi5HSIMOE3oPeT8wgsvlI8++si7+xMYGeg6HDB0Goswz2Qk7xguDz/8sCxatEidOJwujP5PP/1U7rzzTvnyyy/V8AhCHYj2oqdxBPn9448/lvnz58tvf/tbNWL4HxDUKwro6kKFCqkziKHEtg1b1cE2GUYiIhkXLAiE2fgT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xnbSpElq6OAh0Y/O6GGMkJ8iRYro54EDB0r37t3VOIIpU6aonBGF8Kc5uAeuXKBdyJ3LT9uop7+OvMcpTDcfuHfo0CHN6+p68OBBqV27tuZzdaHOGJTIPGVh1A4dOvQYBex/ljxE7XiOd7hyMAiZV6VLl9Zn3Nj46/P111+rPD3//PMyY8aM4/qBcvDQXnvtNU1L1MbThajzhT5mDBm3li1bJpwL/v5mfMaMGRM6Zv75hFwgQ8g188CVRx7qh97h+X379smQIUOkfPny+uy99957jExw/5VXXpFWrVqlv48xnzlz5jF5KAPZ8OOvt5MF9Gtwrjn5QF7RaQ0bNtT6uzojs65uifSIX0ckSksm0w7/nKGdy5cvP06eabM/bcKECdom9Dptob7oqJdeekluuOEGnRcuv5vb6PbgHDLCyfJf6CxQoICsXr1aHn30USlcuLBcffXV8oc//EHeffddXawxKACh7Nu3ryrKiy++WBdutldYRG6++WYdvObNm+viwIDzPFbvddddp8YGwsBgBhex2267TWrWrCnDhw+X/v37q4FBGos4dfv444+lR48esmfPHi0/SKNGjeSMM86Qt99+Ww2HSy65RIUJwp7HeBk2bJi2DUMFYfZHOzAWiLBQDlsfdPC6devksssu00mH0US7SHMweWg/Rhn9F4dhkQoYFqtWrfI+HQv9zWTq3bu3lCxZUusKKEIUE+n0ExPTQR76lQnNsygIB/lQgv369VOjCiVNOeSj76pXry4lSpTQMurWratGZalSpfQzBivP+EHZTp06VfsURQ+uvrSLBaBs2bL6mfQoyoD6oticvFFHjGmeD3piKLhmzZrpPZQPygmoKzJPOgs4be7cubNug/EM6bTXKWs//mc3bdqkfUYfuXK4kHXukYd+Zp6Rj7oyH0nHKGNOAkobSHd948YSkrXRSE7YXKC/cUqc3CFTicbMXwYyxFgwH/3lAXMDWed5xph8fu6+++70+yycP//5z/U96B1+IvvBPLfccov39I8E643xi04G/1zzywfyihHBnOY5ZNfJmyOoR9DpQR1BOymHz1xFixZNKtN+/HMGA4pn/HqFNgRlfO3atd7T4TBPKYP+o22Qqi4xfiRTxgWe+uLFi2XatGny5ZdfqqUyZ84cWb9+vQ44ggRMFq758+fLN998o5OJhRfPngmF4J511lm6IBMlQIgxKDLioosuUquZiYKx8sEHH+iCxHupG4KF14xR4OriwIjAONi9e7dGIBBghMcZIWHPI9gcwqSN/KSNXA764quvvlIDCgMDL5gyeJ7PLHZMKj9470QtuOdX+LkBJjd9g3WPl8QF9BWTDyXD5PNDOkoJY5KF0MEY/+pXv1Kvg+fwhigPT4rFHI/l6NGjOh6kY2S89957qnD4jGcSXPQ2b96cHslgwWTSU5arL94Z3hSKPbMgt4yLU/JB8PR45+233651ps3UFRkBDCKiWsgERiTKD/Cu6Kcg/me3bt2a3teuHDxEFClzDriHsYox5k8nP30JYX3D5ciojUZiwuYC/c28d/JK34aNGYYzuDLQBVzISHBuoducrKOTMDzQV0D56FRk0C+LzB1Hojz+ORqsN3LIIg/+ueYHeUVf8wwXBpSrlyOoR5DLoI4gKlCtWjWtGxe/J5NpP/45E6ZX0N1ZlXHenVVdcrqSI2cuiBK4bQ4WGsLRRCcQSMeRI0fkhx9+8D6lBkIWFbZEWNQJ12GYYCwgyCjvRNx66626SCJgGEUsFn6YgEx8JhfKnIgHBgeWPAYQXgFRHv+E/stf/qILFMbVAw88cJxHkt2wYAWVATAR8bSx0GkLBmNU8FRQOER5aJsDQ8y/qGFAOk+Ai+fwKIgMEX1ia4kx5XNGngYQbXBlNW7cWD0jvBQUC4om6FFFgfbjudAXwQNqlIfi4n28K8xYyC0E+8a/UCRro3FygOy5SABXmHcelscZEtlFIj0SpiOYo65uXMhsZgjTK0EZ9xteUaCfsqpLTley1bggBMgizhYCC/gXX3yhRgZ7aOwLOgt+48aNuqhwPsFtTzicBe3n888/12c7deqk4WkWIbw9rP+MIC91YLFHAHn+k08+UaGjDmFgAOANs4VC1ANLNgjGBIvopZdeqoYGBgfPcKbkhRde0DwcHvXDdtFf//pX3U8sV66cl5oz4BWwteSfLJxA58ApxhMTFQWBUZUKLF4YYG7c6DMMLIxKymOMihcvnr6d4SAShYdFH+LN8ZN34+knAyOJqFDYwohiQVE5IwoPDfBieFdGoFic8eD2sIHyeC84LysRtIvIF54VZJQ/EYsWLdJ6sI0G9CXzi/4FygXeg2cKyfrGkaiNRuqwAPn7GzkOGzNkIio4Jq48to7Rc1zgoryu/DCi5AnWm/fgICWD+UnUAVy70HsOnIlEesSvI2gLeog8DlfnMJlORCK9An4ZJw+OgZuPtJW2ZERQlxgZk63GBYYChxix/LD6OHTJoktojjMNBw4c0HycnWBx/sUvfqGHOydPnqwHJz/99FM9j8BhGz/kZysGi5RtBRZxBDYYUQjCgsKEQHg5xAk8y2FTjJVECzx1R6g4b0G+sPdwZgJljuFCWwDjgWc5IERb/AslW0Pko/4YWzl95gLFx94iBh115GI7p2fPnjouhDKpN4ZPFFAORIIohyiMOywJjA37phgyKAyMDfK795JO+JFohfO63E+naBLBvi1Kg/pSljtMTDiWz7QPQ4qQM4s6aXgxblH2g3KkXhxE4yIv5TKu9JfDGWbcRynz/kRgFNAvLiydUf5koJDde2kj5aI08QRdf2LEuTEL6xu/oZGsjUbqsAD5+xvPPGzM/NGjjEDX4OXzPDCmDhZNnBdXvnsn6Ywn72OxDcvjJ1hv8L8nDOYqOpH8Ye3i96AeYTs7qCN4N9tDlEE69zFyE8l0IpDdML0SlHHWDvrHzUfaHYx8u3lAv7OdG9QlRjQifVskVVBgCAv7eAjP6QARkPvvv1/PXrBAY7ScCPyndQ3DSE5uni8sjizgGS30hpFb8M+nHDlzcaqDEiACQbSFaMWJMiwMwzAMIzeQLZEL48RhkQvDiI7NF8OID4tcGIZhGIaRbZhxYRiGYRhGrJhxYRiGYRhGrJhxYRiGYRhGrJhxYRiGYRhGrORJS0uzb4sYhmEYhpFl3LdF7Kuopxj21TrDiI7NF8OID/sqqmEYhmEY2YYZF4ZhGIZhxIoZF4ZhGIZhxIoZF4ZhGIZhxIoZF4ZhGIZhxIoZF4ZhGIZhxEquNS5uvPFG6datm/fp5KdevXpy9913S6VKlbwUwzAMwzg1iWRctG7dWubOnSsPP/ywlyLSq1cvTeNnVuD5WbNm6Tsof/r06XL55ZdLu3btpH379lKjRg0vZ+bASKHMxYsXy5IlS2Tq1Kly/fXXy/jx4+Whhx7ycmUM9Uj1GT/NmjWTX/7yl9KoUSMv5cRCvy9YsED7hGvixInenRMHdXrqqae8T8eDfIwYMcL7FC/IHHJCn2RVpjOCd9HfyDzwe3a1K0788/N0g7FinLKr7VHK9+fhYiz8OvlUISM94NrOXH3++eeT5k0V/3pkZI1cG7no2rWrGgFr1qzxUlIHg6BLly5y+PBh+f3vfy/169dXo+Wzzz6Tc845R/LkyePlzJhChQql/IwfJsBVV12lBkpuYf369donvXv3liJFipySiioqLVu2lE2bNknjxo1l1KhRXmrO0LFjR+nTp4/3KfcyePBgadOmjSxdutRLMU4UjAFjwZicbvjn6rJly7zUeGDut2jRQmbMmOGlGJkl0l/oxIobMGCAWnROmLHwOnXqJBMmTJCvv/5abr/9dilWrJgcOHBAXn/9dZkzZ44MGjRI9uzZI+XLl5czzjhD3njjDU2744479NmCBQvK559/rgvb008/LXXr1lXPfuDAgdK/f3/ZtWuXjBkzJmE59913nxoL+fPnl61bt0rRokW1HCcYl156qfzxj3/U+t1zzz2yY8cOtXp5tnTp0ppnw4YNsmrVKl34MUJ++OEHFdw6depIvnz5ZOfOnfq+Vq1aHfPMgw8+qFGMmjVrypEjR2TRokW6OLNIhNXJ37ayZctqH5x77rnaLryRLVu2aNr5558ve/fulT//+c/y73//W9+XClH/4iDj16RJEzW+wHnO1J/fMTpgypQpMnPmTB2PgwcPSrVq1bT9jC8GIIwdO1YnpZMTDDHgWahVq5YuoEAf0X5w76A87lOnqlWryr333qvpfniOSBYwjihX6oLsAJ9RCozZvn37ZMiQISovaWlpmoex4zn6H5wMkJeo1hVXXHHMs23btk2vn3uOrS1XHiDrX331ldSuXVvzYDjSBtpP25kr/r6knUOHDj1G/shXokQJWbt2rfahv52uLpTt7/9Dhw6l93kY/nFwZTBWbkuOSBXjPG7cOJXvhg0batvdOFAH5KhMmTLpfeT6040Pz1If2g6uvbSfd1Ee9f7uu++0zbnVIIk6X+hT2kVbWNzohwoVKmg7GQvkgv5NpQ8B+UCnMa6Mlxtb9I9fbkhzY+rycP+1115TfeeXszB59ct/2Fgwbn7ZJl/37t3Ty8wtesAvX/Qpc5f+Iy96NCjj4NLpN/qA9iOrYenLly+XG264QdezRDLubx9rC/qaCIoZJFn4C50oPRdGp/MZYPj000/lkUcekQYNGmioCkVdsWJFvXf06FEdZLZQuN+jRw/dqvjoo490m2Djxo3p5SQjrJzrrrtOy8FQ+eKLL44r54MPPlDhQ4D+8Y9/SN++fTUSwsRBmBAWJ+wICkYE3gATlkX35ptvVsGjw4LP3HbbbToRqceTTz6pUZL7778/wzqdd9550rlzZ1mxYoUaNPQXwtqhQwd9F4va1VdfnSnDIrNgcDHRV65cqZMemPBENFAILD60FUPIKQIMqH79+umEQilRBv2LAUqe0aNH61YQxhrP0kZAafAexpJ8XExglEYymNT0PbLHGGG4objZ5uIz44MnQ3nUgX4El4d0FjoWBpQmBiRp1BGFSTsom88Ygsgv7XfP8Yy/PN7JeNE28lAebWABoe30B1ewnSh86ooi5SftcvA87yed/KtXr05X3P7+d30eRnAcKI/8yCyfaVPJkiV1PDCAGQ/GMRi9ql69enq/+evh4FnXdtde5Bq54H2kL1y4UPOcimBYMNYsqPQNDgp9WKBAgXRZzqgPHTgWlIVMMBYs0EG5wSgJ5nEwZhnJq0tH/hPhl22Xj+coN7foAdrtn6usPY4wGadveC9p1NPp40TpfsJknItxZDxJnzRpkhQuXNh7wvCTknHx1ltvqeLjevXVV9XTBwbALfxNmzaVM888U6MSwCAgREwKBuviiy/Wn1iIRC0+/vhjVdIZkawc0jAkwsrBSyQK8M0336jBwAR1dfODBzp//nz9HWPimWeeUcXBhDvrrLM03c9FF10k5cqVk+HDh6twkofnMqoTefAi6CeMmSuvvFIVEhOfqAWekZuA2U3lypV1kg4bNkzrwsRFiTBpSB85cqQqtVKlSmn9pk2bps8RUWLhcJY+yoZFk7bi3QBlbd++XXbv3q0LLwu2W9AIZfI78sJ78IJ4R6ps3rz5GCWLJ0J5GMEoF/DnYQEA5IiolltIg9AHrn2Ad0YECvzloQy5Bxg7yCiKj/bRR5BKO/FW161bp2WA628Usb//XZ+HERwHB0obQ9aNKRf1ZzGhnVyMk/MmkV3XTvoLGXX3wN92117mpP/d1JN6n4q4scYw4KLN9CHz3pFRHyYjFbmJKq9O/hPhz3sy6QFHmIz7+8bJOCRK9xMm487Acn1AOm0zjicl44LwDxOKi8WYaAIQxUCgunXrlq4YcxMu2oAQX3LJJelhrjCuueYa+dWvfiXz5s3TKESY0DmIPmA9uwvBjgJGGSE39xxbLnfddZeGNjFSHnjggYReTpy4MxcoQb8nTH+RzkU0gG2urIBiZYFEsTgF17NnT91Scwosq9B3TH7Kw8tAMSQChUe7UDDIBAouO6DNcbczM9A+PEyiJNSDcTdyL3jHuUFuTiY9YDKe+4jlQCdW6Lfffqs/M/p2B0YJZxTwHNmu4GeUbZEgziNy5SCwvD8R1Iu9bcJzXOCsez+UkTdvXt1LY9EPWtLumW3btqmn5vbHwXmryerEVsn+/fvVAmZx88Oe/V//+lc14oiK5BREnQBPnjZwNgQFlwpY8IyjC6fiRRD1wavjHv1Ae/FwiNyQl3u8x22hZQUiFUQPgAhAMllwYHDireHh+EHx+fsAwytRpCAZxYsXT6mdKN8qVaqkGztua4fzGFEJjgPQPox/tvUom3EB+oi+AtJ5N3UA6upvP33r+jcRnN8gRIz3Csg/Xt7pSqI+RDeQTp9zZitIqvMjLnn1c7LpgUQyTjucnvW/I1F6RrB+AbINyDrrinE8sRgXCA3W4gsvvKALczLwkt9++21Vai+++KIuCghFqmDlzp49O70cFHnQW2WRnzx5sp67+J//+R/dkuArTHiu7NVxtuGll17ycv/Ihx9+qAsO0RjOU3BoDwid+Z8h8kA4jEOdlM97uJ9RnTjswj4de7YcVuUgKAc+2YahHLZFMGxy8swFsAVEFIXFBcON0CJ9TH/hbWQE/UOInYnNc0ReaCeRLO45w8tFvogIsWXFlkxw/CmDLY6gYkMhoYypUzC8TPjSvZt7ySIXRDnIx4Wyc6FgB96Pvw/AGWCpwNiGtdP1B+n+rRnqwbYI6bwXhYc8JCKsn4LjQGQG5Y0c0x4OomG8An1EX5GPd5LX9QV1pc6ptJ/2UgZzh+dYnE7VbZEohPUh/esfC3QNuIgv+Vkow+TGn8d/NiFVeUXmmAPJ4PncqgfCCPark3F0LAYudfG/I1F6RmDo+9tHlNu9yziWSN8Wye3gCXAoD2uVxT4rX1+NixNVJwyoKKffczMoTv83WYxwstpPGMhs/wWNKxYfjI7MGFR+KAfvkAhRbiW75ktcfZgdYFgQQfEfJs6NxK0HMFIYF3e+zJEoPQrUkQg3fYnxdLrjn0+xRC5OFP/1X/8l7733nrz88ssaCfj73/9+wg2L3Finkw22olLZCjhdyW39hJLGw8Wj4yJykSzyYpwYiNYRBcztxCHfGA1OHolqYABgQCRKj4I7OM7FtwL5GqoZFsdzSkQujJ84FSIXhpFT2HwxjPg4ZSIXhmEYhmHkPsy4MAzDMAwjVsy4MAzDMAwjVsy4MAzDMAwjVsy4MAzDMAwjVvKkpaXZt0UMwzAMw8gy7tsi9lXUUwz7ap1hRMfmi2HEh30V1TAMwzCMbMOMC8MwDMMwYsWMC8MwDMMwYsWMC8MwDMMwYsWMC8MwDMMwYsWMC8MwDMMwYsWMC8OIkaeeekp69erlfTIMwzg9iWRctG7dWubOnZv+P+z5nbScgv+9P336dLn88su9FCMu6Ntk4zlu3LhcvVgiE8gG7cgsPDtixAjvU3KS5SW9adOmcvvtt8vEiRO91PA6+udUZmWb8tyzo0eP1jIZKwwcoA5R22Ukx41XmJzRx4xD586dU5JF//hlFp5lnDOrj6nDqSYjyfrEjWN2rWG5XV/mJClFLqZMmSL169eXZs2ayYwZM7xU42SmVq1acvDgQWnbtq2XcnKxdOlSadOmjQwePNhLOTGgUIoWLSrvvfeeLvQdO3bUdJT3sGHD5NChQ/rZccstt8iECRN0Pn333XfSvXt37050aDNtpw/CoA59+vTxPhlZhXGqWrWq9+lHWMgqVqyov69duzYlWcxo/Iz4Qc/NmjXL1rAcINPbItdff73MmTNH/vSnP0mFChVk0qRJ8o9//EO6dOmig7d48WJVtPfff79OQCz0l19+WebPny/z5s3T9MmTJ8v7778v48ePl0qVKqm1icJ1z1PmFVdc4b3xR9q1a6dCwf3Zs2dLz549vTtGqjjL/Y033pCyZcsm9KAaNGiQHrVyXpkbU5fuvB/nQQM/GVPy8lwwb1iag2d4Fi88mAfv4IUXXtA0yvC/kzz+/P56+r0Vfz4MrCDkc5GFBQsWqPHAu9q3b68GQdDjLFWqlOzZs8f79BMsII0bN5atW7d6KT+WfeDAARk1apR+Zh4F+5930U7q4N5Pf1AffoI/ShGGf4vG39euH1yZrn+CbTKOZdu2bfrT9Sm0bNlSdu/erYYHOFn0y4/rV7/MMR5u/LjHODDe3HPjDfzksyuHfGFjdM0116SX7eYJ+dzYZiT7/jq49/vz+WUjiiyRxz3vf9aPvxyeDab5y/bLOeW6/vO/k59EjwYNGqTrCT/J5+B35i5z2NUprI3kc3PP1cvBZ5efZ8NIRV9y319H3ku7SAvLG0zLzaRkXDAoNIxO+uyzz2TRokVSt25d6dq1q5x99tlqDKxZs0YeeeQR7WCEFOPAWfZHjhyRHj16yKZNm9Q4efvtt+XZZ5+VMmXKSPPmzTVP8eLFVSE/88wzUrJkSbnppps0Hc477zwVnhUrVshVV12l5SN8NWrU8HIYqcDY7dq1S9599139XK9ePf3pJ3/+/FKkSBGdlChOJglX//79dRxJHzhwoFSpUkUnRRgNGzaURo0aaT7y402TFy+Qz1x4/cHneW+5cuWOe4e/Tn4vkcmHrPXu3Tv9PXfffbdMnTpVP2O4EjGgDMpy9QkDAxbvhvtjx46VJk2a6LuI3jEHgh7nzJkz9d20NSPKly8vBQoU8D6JbNmyRY2NIBjtQ4YM0fczx1atWqVt49lEfR0GeWmLa+/q1au1PGDuuf5hgWSxNMJBRjdv3ixpaWn6mXnA4owTFYT+xUmiX5EV5hYGpJNNv9wC8oxxyj1kj3dQvnOmSF+4cKHmC5JonqQq+64Ojf/fGMZY9s8lF12LIkvca9Gihaa5Z4NyFSyHKFuyshMRlF/+/DTPb9iwQX/6+5nfmbvMYcaEOoW1EdzccxFIB5/JyzOsT85gc8ShLy+66KJM6cvcRqa2RZxife211+SHH35I/8wg07F0BlYf+89nnnmmFCxYUJ/H8OD66KOP5KuvvtIoBp+///57NRyAv0vOs0yGHTt2yPnnn6/pgOCULl1ay8XbvvLKK1XRXnDBBV4OIxUQ1pUrV+rY4VnXqVPHu/MTbJngWcOyZcvUGGEBZZynTZum6Si/devWqUIKAyOUidu3b1+daMC7qlWrlm6J83vweZ5hYQXegYdIHn+d/KDoUcBu0WfioyQ4A8E7+FmiRAk1FKgvZQKLdhjOq3HPubqHwTuZBx988IHmj8OzQLlSR4wPLgwY3oPiTAX62t9eN24sdiyWLoKSqB+Mn0BnAbKFwYAs4mgFoS+d1w3MnXz58ukiEway7sZl+fLlushTPttpjLtLJ1+QsHmC45Cq7PvrEJxLzDcWtCiyhN7evn17+r0wuQqWA8nKTkRW5DdRG8HNvSCMJ07tyJEj1Ung8hOHvvz00091LFLVl7mNTG+LOIhGAEYGIMRMiG7duoUOTlQKFSokefPmTS/fcfjwYQ0dYeFytWrVSt58803vrhEVJknlypXTlQ9GI1Z8sgU0K2DxY3xy/sAtvO697gp6c3HAJHUeABcGQNj2RRCiIHgmPMPzYUo9DAzll156KdSrcQQjFcFIhpF7YeFkwWDvnoWaLd4wkOV+/fpp5IFILyB7LIDIvT8Unl1kVvaNcJjPjCdjS3+uX7/euxM/J0pfxkmWjItOnTqpAfDOO++odXbttddqWOjbb7/Vn5nZrsBKxWKnbEJefi/tiy++kP379+u73F6hkTmwhPGy/cKKMooSFneRCHcIlElHmG/nzp1q+eM1Afex2B14GHhY5CFSUrNmzYQLMPCsKwtjCM8L7y0RKG7Cic5AYiGA4GFV3u03pMJkCTlkEQHq4G9HRmAYJ8tPvc4999x0r5YQOHVyHlTcEJ1ifFxfu/7wnwMxooMHivwgx3iniWA8nWFKxBVYEIgAJ/PGHRihhQsXTt+uTCSHYfPEefGZkX0IziVkFMMkLlkKlgPJyuYMBXXhHnojDhK1MRE4ATjOzF/qwfoUhWT6EtwYMHZEmxyp6svcRqbOXHCNGTNGBdodvCQc1KFDBxUQFioO3GF4ZIann35aPepPPvlEy3GwZcK7GADez6CR10gNJhPKjbHyw2SLarQh9Ag7ssDBKbaymAyEBJkApDMpmFQYg9wnjT1UvD2ULKFHniWd+8GJw7NMfvccY58sGkaZPEPIkmfYP+VMj6snF15AMF8YLCDuOepAfsC4Id0d/nK4w1Zs2TFPCLcmqiuLDtt6tMm9Pzu/1cG4EIZ1fc3iMnToUO+ukSqMK/vnjGMig9Ad/EPGMFJZmNzBTM4juBB5MngP88JFF/1y6CdsngwfPjzTsg9h+ZDRuGQpWA79lahs0on0UZcBAwboVkgyGBP6nHKSRYgStTERwXrs3bvXu5MxifQlW14Yh6QTFWE7iTMXmdGXuY08F1544VHv9xMOAoZQZKeiPdXx/z/9kxkWbvanmZRZ2V7LaTjVzlcSURxG7udkmi8slBj/wUOGhpFb8M+nLJ+5MAzjJ+69914zLIxYwMD2f32R6IRFnIyThVwVuTCyzqkSuTCMnMDmi2HEh0UuDMMwDMPINsy4MAzDMAwjVvLyh10MwzAMwzAyC7YEf4fKkbdYsWLer4ZhGIZhGKmDLeH/qrRGLviDPhbBMAzDMAwjFfw2BP/Ww6HfFuGfhfGHPPg/IIZhGIZhGFFgK4SIhd+wAPsqqmEYhmEYsWLfFjEMwzAMI1bMuDAMwzAMI1bMuDAMwzAMI0ZE/g8lxWoXc55s6QAAAABJRU5ErkJggg==)

## Missing Report
"""

def check_missing_values(df):
    # 1. Check for standard missing values (NaN)
    missing_standard = df.isnull().sum()

    # 2. Check for missing values represented as empty strings
    missing_empty_string = (df == '').sum()

    # 3. Check for missing values represented as spaces
    missing_spaces = (df == ' ').sum()

    # 4. Check for missing values in strings like "None", "NA", "N/A", etc.
    # Customize this list as needed
    missing_custom = df.isin(['None', 'NA', 'N/A', 'null', 'nan']).sum()

    # Combine all checks into a single DataFrame for convenience
    missing_report = pd.DataFrame({
        'Missing (NaN)': missing_standard,
        'Missing (Empty Strings)': missing_empty_string,
        'Missing (Spaces)': missing_spaces,
        'Missing (Custom)': missing_custom
    })
    return missing_report

# Call the function and print the results
missing_values_report = check_missing_values(df_cleaned)
print(missing_values_report)

#Handling Missing Values
df_cleaned['subdomain'] = df_cleaned['subdomain'].replace('', 'none')
df_cleaned['Registrant Name'] = df_cleaned['Registrant Name'].fillna('Unknown')
df_cleaned['Emails'] = df_cleaned['Emails'].fillna('Unknown')
df_cleaned['Organization'] = df_cleaned['Organization'].fillna('Unknown')
df_cleaned['Country'] = df_cleaned['Country'].fillna('Unknown')
df_cleaned['longest_word'] = df_cleaned['longest_word'].replace('', 'none')

# Call the function and print the results
missing_values_report = check_missing_values(df_cleaned)
print(missing_values_report)

# from google.colab import files

# df_cleaned.to_csv('malicious_url_features.csv', encoding='utf-8')
# files.download('malicious_url_features.csv')

"""### Z Score -Outlier Detection"""

data = df_cleaned
#ORIGINAL DATASET
#data = pd.read_csv(/content/drive/My Drive/ml_datasets/phistank_clean.csv)

numerical_columns = data.select_dtypes(include=['float64', 'int64']).columns

# Calculate Z-scores
data['z_score_outlier'] = (np.abs(data[numerical_columns] - data[numerical_columns].mean()) / data[numerical_columns].std()).max(axis=1)

# Set threshold for flagging outliers (e.g., Z-score > 3 is considered an outlier)
threshold = 3
data['is_outlier'] = data['z_score_outlier'] > threshold

# Optional: Remove outliers
data_no_outliers = data[data['is_outlier'] == False]

# Save or further process the clean dataset
data_no_outliers.to_csv('cleaned_data_without_outliers_z_score.csv', index=False)

# Optionally, display how many outliers were detected
print(f'Number of outliers detected: {data["is_outlier"].sum()}')

# Scatter plot to visualize Z-Scores
plt.figure(figsize=(10, 6))
plt.scatter(range(len(data)), data['z_score_outlier'], c=data['is_outlier'].map({True: 'red', False: 'green'}))
plt.axhline(y=threshold, color='green', linestyle='solid', label=f'Threshold Z-Score = {threshold}')
plt.title('Z-Score Outliers Visualization')
plt.xlabel('Index')
plt.ylabel('Z-Score')
plt.legend()
plt.show()

"""### Isolation Forest - Outlier Detection"""

# Import necessary libraries
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import warnings
# Ignore all warnings
warnings.filterwarnings('ignore')

data = df_cleaned

# # Select numerical columns for outlier detection
numerical_columns = data.select_dtypes(include=['float64', 'int64']).columns

# # Scale the numerical data
scaler = StandardScaler()
scaled_data = scaler.fit_transform(data[numerical_columns].fillna(0))  # Fill missing values with 0 or use a suitable method

# Apply Isolation Forest for outlier detection
isolation_forest = IsolationForest(contamination=0.05, random_state=42)
outlier_predictions = isolation_forest.fit_predict(scaled_data)

# Add outlier predictions to the original data
data['outlier_isolation_forest'] = outlier_predictions

# Optional: Remove outliers from the dataset (keep only non-outliers)
data_no_outliers = data[data['outlier_isolation_forest'] == 1]

# Save or further process the clean dataset
data_no_outliers.to_csv('cleaned_data_without_outliers.csv', index=False)
# Isolation Forest method has identified three potential outliers (marked with -1), while the rest of the data points (marked with 1) are considered normal.
data_no_outliers.head()

"""### Common Outlier Detection"""

# Assuming `data` has the columns 'is_outlier_zscore' and 'is_outlier_isolation_forest' from previous steps
data['is_common_outlier'] = (data['is_outlier'] & data['outlier_isolation_forest'])

# Filter data to remove common outliers
cleaned_data_common_outliers = data[data['is_common_outlier'] == False]

# Optional: Save or further process the cleaned data
cleaned_data_common_outliers.to_csv('cleaned_data_common_outliers.csv', index=False)

# Scatter plot to visualize common outliers
plt.figure(figsize=(10, 6))

# Plot non-outliers in blue and common outliers in red
# Replace 'some_numerical_column' with an actual numerical column from your dataset for visualization
plt.scatter(data.index, data['outlier_isolation_forest'],
            c=data['is_common_outlier'].map({True: 'red', False: 'blue'}), label='Common Outliers')

# Optional: Customize the plot
plt.axhline(y=0, color='green', linestyle='--', label='Threshold')
plt.title('Common Outliers Highlighted (Red) by Both Methods')
plt.xlabel('Index')
plt.ylabel('Value')
plt.legend()

# Show the plot
plt.show()

# Combine results (union of both methods' outliers)
data['is_combined_outlier'] = (data['is_outlier'] |
                                             data['outlier_isolation_forest'])

# Remove the combined outliers
#cleaned_data_combined = data[data['is_combined_outlier'] == False]
cleaned_data_common_outliers.head()

"""## Machine Learning Models

### 1. Logisitic Regression
"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
import warnings

# Ignore all warnings
warnings.filterwarnings('ignore')

# Step 1: Define the feature columns and target column
# Drop non-numeric columns like 'url', 'Registrar', 'Registrant Name', etc.
# Keep only numeric columns for scaling
numeric_columns = data.select_dtypes(include=['float64', 'int64']).columns
target_column = 'target'

# Check for numeric columns
print("Numeric columns used for training:", numeric_columns)

X = data[numeric_columns]  # Select only numeric features
y = data[target_column]    # Target


# Step 2: Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Step 3: Feature Scaling using StandardScaler
scaler = StandardScaler()

# Fit and transform the scaler on the training data, transform the test data
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Step 4: Initialize and train the logistic regression model
model_lr = LogisticRegression(max_iter=1000)
model_lr.fit(X_train_scaled, y_train)

# Step 5: Make predictions
y_pred_lr = model_lr.predict(X_test_scaled)

# Step 6: Evaluate performance
print("Logistic Regression Accuracy:", accuracy_score(y_test, y_pred_lr))
print(classification_report(y_test, y_pred_lr))

"""### 2. Random Forest"""

# Ignore all warnings
warnings.filterwarnings('ignore')
# Initialize and train the Random Forest model
model_rf = RandomForestClassifier(n_estimators=100, random_state=42)
model_rf.fit(X_train_scaled, y_train)

# Make predictions
y_pred_rf = model_rf.predict(X_test_scaled)

# Evaluate performance
print("Random Forest Accuracy:", accuracy_score(y_test, y_pred_rf))
print(classification_report(y_test, y_pred_rf))

"""### SUPPORT VECTOR MACHINE (SVM)"""

# Initialize and train the SVM model
model_svm = SVC(kernel='linear')
model_svm.fit(X_train_scaled, y_train)

# Make predictions
y_pred_svm = model_svm.predict(X_test_scaled)

# Evaluate performance
print("SVM Accuracy:", accuracy_score(y_test, y_pred_svm))
print(classification_report(y_test, y_pred_svm))

"""# Severity Scores for URLs

## Training an Classifier
"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report

# Assume `X` contains the features and `y` contains labels (phishing, malware, spam)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Train the model
model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

# Make predictions (with probability)
y_pred_prob = model.predict_proba(X_test)

# Display the classification report
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

"""## Assigning Severity Score and Severity Level using ML"""

def assign_severity_score(pred_prob):
    """Assign a severity score based on the predicted probability."""
    # Assuming the second class (index 1) is phishing, for example
    phishing_prob = pred_prob[1]

    # Assign a score between 1 and 10
    if phishing_prob > 0.9:
        return 10  # Very high risk
    elif phishing_prob > 0.7:
        return 8   # High risk
    elif phishing_prob > 0.5:
        return 6   # Moderate risk
    else:
        return 2   # Low risk

def assign_severity_level(score):
    """Assign severity level based on severity score."""
    if score > 7:
        return 'High'
    elif score >= 4:
        return 'Medium'
    else:
        return 'Low'

# Make predictions on the entire dataset
y_pred_prob_all = model.predict_proba(X)

# Apply the severity score function to the predicted probabilities
severity_scores_all = [assign_severity_score(pred) for pred in y_pred_prob_all]

# Ensure the length of predictions matches the length of the dataframe
if len(severity_scores_all) == len(data):
    # Assign severity scores to the dataframe
    data['pred_severity_score'] = severity_scores_all

    # Apply the severity level based on the severity score
    data['pred_severity_level'] = data['pred_severity_score'].apply(assign_severity_level)
else:
    print("Mismatch in length of predictions and data")

# Display the DataFrame with severity scores and levels
data[['url', 'pred_severity_score', 'pred_severity_level']].head()

"""#  Rule-Based Approach for Severity Scoring (Without ML)"""

import re

def assign_severity_by_rules(url):
    """Assign severity score based on heuristics and rules."""
    score = 0

    # Rule 1: Longer URLs are suspicious
    if len(url) > 75:
        score += 3

    # Rule 2: Suspicious keywords in URL
    suspicious_keywords = [
        'login', 'secure', 'free', 'win', 'bank', 'account', 'verify', 'update', 'password', 'reward',
        'gift', 'prize', 'money', 'bonus', 'discount', 'insurance', 'paypal', 'invoice', 'investment',
        'deal', 'winner', 'claim'
    ]
    if any(keyword in url.lower() for keyword in suspicious_keywords):
        score += 5

    # Rule 3: Special characters in URL (obfuscation attempts)
    if any(char in url for char in ['@', '%', '&', '=']):
        score += 2

    # Rule 4: IP address in URL (phishing attempts often use IP-based URLs)
    if re.search(r'http[s]?://(?:[0-9]{1,3}\.){3}[0-9]{1,3}', url):
        score += 4

    # Rule 5: URL using HTTP (non-HTTPS can be less secure)
    if url.startswith('http://'):
        score += 2

    # Rule 6: Multiple subdomains in the URL
    subdomain_count = url.count('.')
    if subdomain_count > 3:
        score += 2

    # Rule 7: Obfuscated URLs (percent-encoding like %20, %3A, etc.)
    if re.search(r'%[0-9a-fA-F]{2}', url):
        score += 3

    # Cap the score at 10 to keep it within a reasonable range
    return min(score, 10)

def severity_level(score):
    """Assign risk level based on severity score."""
    if score > 7:
        return 'High'
    elif score >= 4:
        return 'Medium'
    else:
        return 'Low'

# Apply severity score to your dataset
data['severity_score'] = data['url'].apply(assign_severity_by_rules)

# Apply risk level based on severity score
data['severity'] = data['severity_score'].apply(severity_level)

# Show the updated dataset with severity score and risk level
data[['url', 'severity_score', 'severity']].head()

"""### GOOGLE SAFE BROWSING SCORE CHECK"""

import requests
import time

# Replace with your Google API key
API_KEY = 'AIzaSyBl2tzdJ4fjeKBevTE9YsSUnSZHrjR3Xso'

# Function to get reputation and threat type from Google Safe Browsing API
def get_google_safebrowsing_reputation(url):
    """Fetch reputation data from Google Safe Browsing API and return both score and threat type."""

    api_url = 'https://safebrowsing.googleapis.com/v4/threatMatches:find?key=' + API_KEY
    payload = {
        "client": {
            "clientId": "MY_First_Project",
            "clientVersion": "1.0"
        },
        "threatInfo": {
            "threatTypes": [
                "MALWARE",
                "SOCIAL_ENGINEERING",
                "UNWANTED_SOFTWARE",
                "POTENTIALLY_HARMFUL_APPLICATION"
            ],
            "platformTypes": ["ANY_PLATFORM"],
            "threatEntryTypes": ["URL"],
            "threatEntries": [
                {"url": url}
            ]
        }
    }

    try:
        response = requests.post(api_url, json=payload, timeout=10)  # Timeout of 10 seconds
        response.raise_for_status()  # Raise error for bad status codes
        json_response = response.json()

        # Check if any threats were found
        if 'matches' in json_response:
            # Extract threat type
            threat_info = json_response['matches'][0]['threatType']
            return ("Unsafe", threat_info)  # Unsafe with specific threat type
        else:
            return ("Safe", None)  # URL is safe
    except requests.exceptions.RequestException as e:
        print(f"Error checking {url}: {e}")
        return ("Error", None)

# Apply the function to each URL in your dataset with retry logic
def safe_browsing_reputation_with_retry(url, max_retries=3, wait=2):
    """Retry Safe Browsing reputation check in case of network issues."""
    for attempt in range(max_retries):
        score, threat_type = get_google_safebrowsing_reputation(url)
        if score != "Error":
            return score, threat_type
        time.sleep(wait)  # Wait before retrying
    return "Failed after retries", None

# Example: Apply the function to your dataset
results = data['url'].apply(safe_browsing_reputation_with_retry)

# Create two separate columns from the results
data['google_safe_browsing_score'], data['google_safe_browsing_threat'] = zip(*results)

# Show the updated dataset with Google Safe Browsing scores and threat types
data.head()

"""## Visulize Severity vs Google Score"""

# Create subplots for each severity score
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# 1. Severity Score Distribution
severity_counts = data['severity_score'].value_counts().sort_index()
axes[0].bar(severity_counts.index, severity_counts.values)
axes[0].set_xlabel('Severity Score (Rule-Based)')
axes[0].set_ylabel('Frequency')
axes[0].set_title('Distribution of Rule-Based Severity Scores')

# 2. Google Safe Browsing Score Distribution
google_safe_browsing_counts = data['google_safe_browsing_score'].value_counts()
axes[1].bar(google_safe_browsing_counts.index, google_safe_browsing_counts.values)
axes[1].set_xlabel('Google Safe Browsing Score')
axes[1].set_ylabel('Frequency')
axes[1].set_title('Distribution of Google Safe Browsing Scores')

# 3. Pred_Severity Score Distribution
pred_severity_counts = data['pred_severity_score'].value_counts().sort_index()
axes[2].bar(pred_severity_counts.index, pred_severity_counts.values)
axes[2].set_xlabel('Pred Severity Score (ML Based)')
axes[2].set_ylabel('Frequency')
axes[2].set_title('Distribution of ML Pred Severity Scores')

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Assuming 'data' DataFrame has 'severity', 'google_safe_browsing_score', and 'pred_severity_level' columns

# Count the occurrences of each severity level
severity_counts = data['severity'].value_counts()

# Count the occurrences of each Google Safe Browsing score
google_safe_browsing_counts = data['google_safe_browsing_score'].value_counts()

# Count the occurrences of each predicted severity level
pred_severity_counts = data['pred_severity_level'].value_counts()

# Create subplots for each pie chart
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# 1. Severity Level Pie Chart
axes[0].pie(severity_counts, labels=severity_counts.index, autopct='%1.1f%%', startangle=90)
axes[0].set_title('Severity Level (Rule-Based)')

# 2. Google Safe Browsing Score Pie Chart
axes[1].pie(google_safe_browsing_counts, labels=google_safe_browsing_counts.index, autopct='%1.1f%%', startangle=90)
axes[1].set_title('Google Safe Browsing Score')

# 3. Predicted Severity Level Pie Chart
axes[2].pie(pred_severity_counts, labels=pred_severity_counts.index, autopct='%1.1f%%', startangle=90)
axes[2].set_title('Predicted Severity Level (ML-Based)')

plt.tight_layout()
plt.show()

data.to_csv('malicious_url_features_final.csv', encoding='utf-8')
files.download('malicious_url_features_final.csv')

"""#                                                                                 ------------------------------- THE END --------------------------------"""